webpackJsonp([0,1],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// *********************
	//    Modules scripts
	// *********************
	
	// MINIFIED Vendor file should be copied over via copyScripts.js (it is by default)
	
	// IMPORT all modules here. Keep lib and minified files out this file.
	// Except for the example below
	
	'use strict';
	
	__webpack_require__(2);
	
	__webpack_require__(3);
	
	__webpack_require__(5);
	
	__webpack_require__(6);
	
	__webpack_require__(7);
	
	__webpack_require__(9);
	
	__webpack_require__(10);
	
	__webpack_require__(13);
	
	__webpack_require__(14);
	
	__webpack_require__(15);
	
	__webpack_require__(16);
	
	__webpack_require__(12);
	
	//import 'lib/init'

	// USING production variables is simple with the envVar function
	// Burn after reading

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	
	var bLazy = new Blazy({
		offset: 500,
		breakpoints: [{
			// Max-width
			width: 767,
			src: 'data-src-sm'
		}]
	});

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _libInstafeedCustom = __webpack_require__(4);
	
	var _libInstafeedCustom2 = _interopRequireDefault(_libInstafeedCustom);
	
	//clientId: '161217bc3cce40ab81b9ffb79abd0ab3'
	
	//don't load too many, because these aren't small
	
	//randomize it...
	//0 or 1
	
	(function instafeedModule() {
		if (document.querySelector('#instafeed')) {
			var feed;
			var arrayOfBrickGroups;
	
			(function () {
				var shuffle = function shuffle(array) {
					var currentIndex = array.length,
					    temporaryValue,
					    randomIndex;
	
					// While there remain elements to shuffle...
					while (0 !== currentIndex) {
	
						// Pick a remaining element...
						randomIndex = Math.floor(Math.random() * currentIndex);
						currentIndex -= 1;
	
						// And swap it with the current element.
						temporaryValue = array[currentIndex];
						array[currentIndex] = array[randomIndex];
						array[randomIndex] = temporaryValue;
					}
	
					return array;
					console.log(array);
				};
	
				var putImagesInCustomGrid = function putImagesInCustomGrid() {
					var collectionOfBrickContainers = document.querySelectorAll('.brick');
					var arrayOfInstagramImageWrappers = Array.prototype.slice.call(document.querySelectorAll('.instragram__image--wrapper'));
	
					//shuffle the array NOT WORKING
					console.log(arrayOfInstagramImageWrappers);
					arrayOfInstagramImageWrappers = shuffle(arrayOfInstagramImageWrappers);
					console.log(arrayOfInstagramImageWrappers);
	
					for (var i = 0; i < collectionOfBrickContainers.length; i++) {
						//collectionOfBrickContainers[i].innerHTML = arrayOfInstagramImageWrappers[i];
	
						collectionOfBrickContainers[i].appendChild(arrayOfInstagramImageWrappers[i]);
					}
					setInstagramSrc();
				};
	
				var setInstagramSrc = function setInstagramSrc() {
					var arrayOfInstagramImages = document.querySelectorAll('.instagram__image');
					for (var i = 0; i < arrayOfInstagramImages.length; i++) {
						var theInstagramSrcOfThisImage = arrayOfInstagramImages[i].getAttribute('instagram-src');
						arrayOfInstagramImages[i].setAttribute('src', theInstagramSrcOfThisImage);
					}
				}
	
				//timeline
	
				;
	
				console.log(Math.random());
	
				feed = new _libInstafeedCustom2['default']({
					get: 'user',
					userId: '226965373',
					accessToken: '226965373.372a9ca.d1ef6f357358406082a07a93424dd6c9',
					tags: 'catsofinstagram',
					//standard is highest resolution
					resolution: 'standard_resolution',
					limit: 18,
					//target blank
					template: '<a class="instragram__image--wrapper instragram__link" target="_blank" href="{{link}}"><img class="instagram__image" instagram-src="{{image}}" /></a>',
	
					after: function after() {
						putImagesInCustomGrid();
					}
				});
	
				feed.run();
	
				arrayOfBrickGroups = document.querySelectorAll('.brick-group');
	
				//var instagramCollageTimeline = new TimelineMax({paused:true});
				//instagramCollageTimeline.play();
				// function animateCollage(){
				// }
	
				TweenMax.staggerTo(arrayOfBrickGroups, 2, {
					opacity: 1,
					delay: 0.1,
					ease: Power1.easeOut
				}, 0.1);
			})();
		}
	})();

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.9.3
	'use strict';
	
	(function () {
	  var Instafeed;
	
	  Instafeed = (function () {
	    function Instafeed(params, context) {
	      // default options
	      var option, value;
	      this.options = {
	        target: 'instafeed',
	        get: 'popular',
	        resolution: 'thumbnail',
	        sortBy: 'none',
	        links: true,
	        mock: false,
	        useHttp: false
	      };
	      //if an object is passed in, override the default options
	      if (typeof params === 'object') {
	        for (option in params) {
	          value = params[option];
	          this.options[option] = value;
	        }
	      }
	      // save a reference to context, which defaults to curr scope
	      // this will be used to cache data from parsing to the real
	      // instance the user interacts with (for pagination)
	      this.context = context != null ? context : this;
	
	      //generate a unique key for the instance
	      this.unique = this._genKey();
	    }
	    //method to check if there are more results to load
	    Instafeed.prototype.hasNext = function () {
	      return typeof this.context.nextUrl === 'string' && this.context.nextUrl.length > 0;
	    };
	
	    //method to display next results using the pagination
	    //data from API. Manually passing a url to .run() will
	    //bypass the URL creation from options.
	
	    Instafeed.prototype.next = function () {
	      if (!this.hasNext()) {
	        //check for a valid next url first
	        return false;
	      }
	      //call run with the next results
	      return this.run(this.context.nextUrl);
	    };
	
	    //Make it go
	    Instafeed.prototype.run = function (url) {
	      var header, instanceName, script;
	      //make sure either a client id or access token is set
	      if (typeof this.options.clientId !== 'string') {
	        if (typeof this.options.accessToken !== 'string') {
	          throw new Error("Missing clientId or accessToken.");
	        }
	      }
	      if (typeof this.options.accessToken !== 'string') {
	        if (typeof this.options.clientId !== 'string') {
	          throw new Error("Missing clientId or accessToken.");
	        }
	      }
	      //run the before() callback, if one is set
	      if (this.options.before != null && typeof this.options.before === 'function') {
	        this.options.before.call(this);
	      }
	      //to make it easier to test various parts of the class,
	      //any DOM manipulation first checks for the DOM to exist
	      if (typeof document !== "undefined" && document !== null) {
	        //make a new script element
	        script = document.createElement('script');
	        //give the script an id so it can removed later
	        script.id = 'instafeed-fetcher';
	        //assign the script src using _buildUrl(), or by
	        // using the argument passed to the function
	        script.src = url || this._buildUrl();
	        //add the new script object to the header
	        header = document.getElementsByTagName('head');
	        header[0].appendChild(script);
	        //create a global object to cache the options
	        instanceName = "instafeedCache" + this.unique;
	        window[instanceName] = new Instafeed(this.options, this);
	        window[instanceName].unique = this.unique;
	      }
	      //return true if everything ran
	      return true;
	    };
	    //Data parser (must be a json object)
	    Instafeed.prototype.parse = function (response) {
	      var anchor, childNodeCount, childNodeIndex, childNodesArr, e, eMsg, fragment, header, htmlString, httpProtocol, i, image, imageObj, imageString, imageUrl, images, img, imgHeight, imgOrient, imgUrl, imgWidth, instanceName, j, k, len, len1, len2, node, parsedLimit, reverse, sortSettings, targetEl, tmpEl;
	      //throw an error if not an object
	      if (typeof response !== 'object') {
	        //either throw an error or call the error callback
	        if (this.options.error != null && typeof this.options.error === 'function') {
	          this.options.error.call(this, 'Invalid JSON data');
	          return false;
	        } else {
	          throw new Error('Invalid JSON response');
	        }
	      }
	      //check if the api returned an error code
	      if (response.meta.code !== 200) {
	        //either throw an error or call the error callback
	        if (this.options.error != null && typeof this.options.error === 'function') {
	          this.options.error.call(this, response.meta.error_message);
	          return false;
	        } else {
	          throw new Error("Error from Instagram: " + response.meta.error_message);
	        }
	      }
	      //check if the returned data is empty
	      if (response.data.length === 0) {
	        //either throw an error or call the error callback
	        if (this.options.error != null && typeof this.options.error === 'function') {
	          this.options.error.call(this, 'No images were returned from Instagram');
	          return false;
	        } else {
	          throw new Error('No images were returned from Instagram');
	        }
	      }
	      //call the success callback if no errors in response
	      if (this.options.success != null && typeof this.options.success === 'function') {
	        this.options.success.call(this, response);
	      }
	      //cache the pagination data, if it exists. Apply the value
	      //to the "context" object, which will be a true reference
	      //if this instance was created just for parsing
	      this.context.nextUrl = '';
	      if (response.pagination != null) {
	        this.context.nextUrl = response.pagination.next_url;
	      }
	      //before images are inserted into the DOM, check for sorting
	      if (this.options.sortBy !== 'none') {
	        //if sort is set to random, don't check for polarity
	        if (this.options.sortBy === 'random') {
	          sortSettings = ['', 'random'];
	        } else {
	          //get the sort settings from @options
	          sortSettings = this.options.sortBy.split('-');
	        }
	        //determine if the order should be inverse
	        reverse = sortSettings[0] === 'least' ? true : false;
	        //handle the case for sorting
	        switch (sortSettings[1]) {
	          case 'random':
	            response.data.sort(function () {
	              return 0.5 - Math.random();
	            });
	            break;
	          case 'recent':
	            response.data = this._sortBy(response.data, 'created_time', reverse);
	            break;
	          case 'liked':
	            response.data = this._sortBy(response.data, 'likes.count', reverse);
	            break;
	          case 'commented':
	            response.data = this._sortBy(response.data, 'comments.count', reverse);
	            break;
	          default:
	            throw new Error("Invalid option for sortBy: '" + this.options.sortBy + "'.");
	        }
	      }
	      //to make it easier to test various parts of the class,
	      //any DOM manipulation first checks for the DOM to exist
	      if (typeof document !== "undefined" && document !== null && this.options.mock === false) {
	        //limit the number of images if needed
	        images = response.data;
	        parsedLimit = parseInt(this.options.limit, 10);
	        if (this.options.limit != null && images.length > parsedLimit) {
	          images = images.slice(0, parsedLimit);
	        }
	        //create the document fragment
	        fragment = document.createDocumentFragment();
	        //filter the results
	        if (this.options.filter != null && typeof this.options.filter === 'function') {
	          images = this._filter(images, this.options.filter);
	        }
	        //determine whether to parse a template, or use html fragments
	        if (this.options.template != null && typeof this.options.template === 'string') {
	          htmlString = '';
	          imageString = '';
	          imgUrl = '';
	          //create a temp dom node that will hold the html
	          tmpEl = document.createElement('div');
	          //loop through the images
	          for (i = 0, len = images.length; i < len; i++) {
	            image = images[i];
	            imageObj = image.images[this.options.resolution];
	            if (typeof imageObj !== 'object') {
	              eMsg = "No image found for resolution: " + this.options.resolution + ".";
	              throw new Error(eMsg);
	            }
	            imgWidth = imageObj.width;
	            imgHeight = imageObj.height;
	            imgOrient = "square";
	            if (imgWidth > imgHeight) {
	              imgOrient = "landscape";
	            }
	            if (imgWidth < imgHeight) {
	              imgOrient = "portrait";
	            }
	            //use protocol relative image url
	            imageUrl = imageObj.url;
	            httpProtocol = window.location.protocol.indexOf("http") >= 0;
	            if (httpProtocol && !this.options.useHttp) {
	              imageUrl = imageUrl.replace(/https?:\/\//, '//');
	            }
	            //parse the template
	            imageString = this._makeTemplate(this.options.template, {
	              model: image,
	              id: image.id,
	              link: image.link,
	              type: image.type,
	              image: imageUrl,
	              width: imgWidth,
	              height: imgHeight,
	              orientation: imgOrient,
	              caption: this._getObjectProperty(image, 'caption.text'),
	              likes: image.likes.count,
	              comments: image.comments.count,
	              location: this._getObjectProperty(image, 'location.name')
	            });
	            //add the image partial to the html string
	            htmlString += imageString;
	          }
	          //add the final html string to the temp node
	          tmpEl.innerHTML = htmlString;
	          //loop through the contents of the temp node
	          //and append them to the fragment
	          childNodesArr = [];
	          childNodeIndex = 0;
	          childNodeCount = tmpEl.childNodes.length;
	          while (childNodeIndex < childNodeCount) {
	            childNodesArr.push(tmpEl.childNodes[childNodeIndex]);
	            childNodeIndex += 1;
	          }
	          for (j = 0, len1 = childNodesArr.length; j < len1; j++) {
	            node = childNodesArr[j];
	            fragment.appendChild(node);
	          }
	        } else {
	          //loop through the images
	          for (k = 0, len2 = images.length; k < len2; k++) {
	            image = images[k];
	            //create the image using the @options's resolution
	            img = document.createElement('img');
	            //use protocol relative image url
	            imageObj = image.images[this.options.resolution];
	            if (typeof imageObj !== 'object') {
	              eMsg = "No image found for resolution: " + this.options.resolution + ".";
	              throw new Error(eMsg);
	            }
	            //use protocol relative image url
	            imageUrl = imageObj.url;
	            httpProtocol = window.location.protocol.indexOf("http") >= 0;
	            if (httpProtocol && !this.options.useHttp) {
	              imageUrl = imageUrl.replace(/https?:\/\//, '//');
	            }
	
	            // creating an achor, but must append to a brick
	
	            //img.src = imageUrl;
	            //img.setAttribute('data-src', imageUrl);
	            img.setAttribute('instagram-src', imageUrl);
	            img.classList.add('instafeed-image');
	            //wrap the image in an anchor tag, unless turned off
	            if (this.options.links === true) {
	              //create an anchor link
	              anchor = document.createElement('a');
	              anchor.href = image.link;
	              // add the image to it
	              anchor.appendChild(img);
	              //add the anchor to the fragment
	              fragment.appendChild(anchor);
	            } else {
	              //add the image (without link) to the fragment
	              fragment.appendChild(img);
	            }
	          }
	        }
	        //add the fragment to the dom:
	        //if target is string, consider it as element id
	        //otherwise consider it as element
	        targetEl = this.options.target;
	        if (typeof targetEl === 'string') {
	          targetEl = document.getElementById(targetEl);
	        }
	        if (targetEl == null) {
	          eMsg = "No element with id=\"" + this.options.target + "\" on page.";
	          throw new Error(eMsg);
	        }
	        targetEl.appendChild(fragment);
	        //remove the injected script tag
	        header = document.getElementsByTagName('head')[0];
	        header.removeChild(document.getElementById('instafeed-fetcher'));
	        //delete the cached instance of the class
	        instanceName = "instafeedCache" + this.unique;
	        window[instanceName] = void 0;
	        try {
	          delete window[instanceName];
	        } catch (_error) {
	          e = _error;
	          //END if document?
	        }
	      }
	      //run after callback function, if one is set
	      if (this.options.after != null && typeof this.options.after === 'function') {
	        this.options.after.call(this);
	      }
	      //return true if everything ran
	      return true;
	    };
	
	    //helper function that structures a url for the run()
	    // function to inject into the document hearder
	    Instafeed.prototype._buildUrl = function () {
	      var base, endpoint, final;
	      //set the base API URL
	      base = "https://api.instagram.com/v1";
	      //get the endpoint based on @options.get
	      switch (this.options.get) {
	        case "popular":
	          endpoint = "media/popular";
	          break;
	        //make sure a tag is defined
	        case "tagged":
	          if (!this.options.tagName) {
	            throw new Error("No tag name specified. Use the 'tagName' option.");
	          }
	          //set the endpoint
	          endpoint = "tags/" + this.options.tagName + "/media/recent";
	          break;
	        //make sure a location id is defined
	        case "location":
	          if (!this.options.locationId) {
	            throw new Error("No location specified. Use the 'locationId' option.");
	          }
	          //set the endpoint
	          endpoint = "locations/" + this.options.locationId + "/media/recent";
	          break;
	        //make sure there is a user id set
	        case "user":
	          if (!this.options.userId) {
	            throw new Error("No user specified. Use the 'userId' option.");
	          }
	          //set the endpoint
	          endpoint = "users/" + this.options.userId + "/media/recent";
	          break;
	        default:
	          //throw an error if any other option is given
	          throw new Error("Invalid option for get: '" + this.options.get + "'.");
	      }
	      //build the final url (uses the instance name)
	      final = base + "/" + endpoint;
	
	      //use the access token for auth when it's available
	      //otherwise fall back to the client id
	      if (this.options.accessToken != null) {
	        final += "?access_token=" + this.options.accessToken;
	      } else {
	        final += "?client_id=" + this.options.clientId;
	      }
	      //add the count limit
	      if (this.options.limit != null) {
	        final += "&count=" + this.options.limit;
	      }
	      //add the jsonp callback
	      final += "&callback=instafeedCache" + this.unique + ".parse";
	      //return the final url
	      return final;
	    };
	
	    //helper function to generate a unique key
	    Instafeed.prototype._genKey = function () {
	      var S4;
	      S4 = function () {
	        return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
	      };
	      return "" + S4() + S4() + S4() + S4();
	    };
	    //helper function to parse a template
	    Instafeed.prototype._makeTemplate = function (template, data) {
	      var output, pattern, ref, varName, varValue;
	      //regex Braces, Var Name, Close Braces
	      pattern = /(?:\{{2})([\w\[\]\.]+)(?:\}{2})/;
	      //copy the template
	      output = template;
	      //process the template (null defaults to empty strings)
	      while (pattern.test(output)) {
	        varName = output.match(pattern)[1];
	        varValue = (ref = this._getObjectProperty(data, varName)) != null ? ref : '';
	        output = output.replace(pattern, function () {
	          return "" + varValue;
	        });
	      }
	      //send back the new string
	      return output;
	    };
	
	    //helper function to access an object property by string
	    Instafeed.prototype._getObjectProperty = function (object, property) {
	      var piece, pieces;
	      //convert [] to dot-syntax
	      property = property.replace(/\[(\w+)\]/g, '.$1');
	      //split the object into arrays
	      pieces = property.split('.');
	      //run through the array to find the nested property
	      while (pieces.length) {
	        //move down the property chain
	        piece = pieces.shift();
	        //if they key exists, copy the value
	        // into 'object', otherwise return null
	        if (object != null && piece in object) {
	          object = object[piece];
	        } else {
	          return null;
	        }
	      }
	      //send back the final object
	      return object;
	    };
	
	    // helper function to sort an array objects by an
	    // object property (sorts highest to lowest)
	    Instafeed.prototype._sortBy = function (data, property, reverse) {
	      var sorter;
	      // comparator function
	      sorter = function (a, b) {
	        var valueA, valueB;
	        valueA = this._getObjectProperty(a, property);
	        valueB = this._getObjectProperty(b, property);
	        //sort lowest-to-highest if reverse is true
	        if (reverse) {
	          if (valueA > valueB) {
	            return 1;
	          } else {
	            return -1;
	          }
	        }
	        //otherwise sort highest to lowest
	        if (valueA < valueB) {
	          return 1;
	        } else {
	          return -1;
	        }
	      };
	      //sort the data
	      data.sort(sorter.bind(this));
	      return data;
	    };
	
	    //helper method to filter out images
	    Instafeed.prototype._filter = function (images, filter) {
	      var filteredImages, fn, i, image, len;
	      filteredImages = [];
	      fn = function (image) {
	        if (filter(image)) {
	          return filteredImages.push(image);
	        }
	      };
	      for (i = 0, len = images.length; i < len; i++) {
	        image = images[i];
	        fn(image);
	      }
	      return filteredImages;
	    };
	
	    return Instafeed;
	  })();
	  //set up exports
	  (function (root, factory) {
	    if (true) {
	      return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module === 'object' && module.exports) {
	      return module.exports = factory();
	    } else {
	      return root.Instafeed = factory();
	    }
	  })(this, function () {
	    return Instafeed;
	  });
	}).call(undefined);

/***/ },
/* 5 */
/***/ function(module, exports) {

	"use strict";

	// var msnry = new Masonry( '.bricks-grid', {
	//   columnWidth: 300
	//   ,itemSelector: '.brick'
	//   ,isFitWidth: true
	// });

/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';
	
	(function videoModule() {
	
	  function testForVideo(idToTestFor) {
	    if (document.getElementById(idToTestFor)) {
	      writeBrightCoveToDocument();
	    }
	  }
	
	  function writeBrightCoveToDocument() {
	    var codeToAppend = document.createElement('script');
	    var whereToAppend = document.body;
	    var theVideoPlayer = document.getElementById('iftVideo').getAttribute('data-player');
	    //might want to use a helper function to set multiple properties at once
	    codeToAppend.setAttribute('async', 'true');
	    codeToAppend.setAttribute('src', '//players.brightcove.net/1377104878001/' + theVideoPlayer + '_default/index.min.js');
	    whereToAppend.appendChild(codeToAppend);
	    //waits for scrpt to load
	    codeToAppend.addEventListener('load', videoInit);
	  }
	
	  function videoInit() {
	    console.log('brightcove js file loaded');
	    var iftVideo = document.getElementById('iftVideo');
	    /*must use video ready event*/
	    videojs(iftVideo).ready(function () {
	      var theVideo = this;
	      theVideo.on('play', addPlayState);
	      theVideo.on('pause', removePlayState);
	    });
	  }
	
	  function removePlayState() {
	    document.body.classList.remove('video-playing--STATE');
	  }
	
	  function addPlayState() {
	    document.body.classList.add('video-playing--STATE');
	  }
	
	  function addPausedState() {
	    document.body.classList.add('video-paused--STATE');
	  }
	
	  function addPlayerStateToBody() {}
	
	  window.addEventListener('load', testForVideo('iftVideo'));
	  //want to wait as long as possible
	})();
	
	// var isPaused = myPlayer.paused();
	// var isPlaying = !myPlayer.paused();

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	//if menu is open, and there's a hash change, close the menu
	//that gives us back functionality
	
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _libUtilFunctionsRevisedJs = __webpack_require__(8);
	
	var _libUtilFunctionsRevisedJs2 = _interopRequireDefault(_libUtilFunctionsRevisedJs);
	
	(function navModule() {
		var theSubnavOfTheItemThatHasBeenClicked;
		var theSVGOfTheItemThatHasBeenClicked;
		var theTopLevelItemThatHasBeenClicked;
	
		var navOverlayCloseTarget = document.getElementById('navOverlayCloseTarget');
	
		var navLevel2CloseButton = document.getElementById('navLevel2CloseButton');
	
		var navTopLevelItems = document.querySelectorAll('.nav-list-top-level > li');
		var theNavSVGS = document.querySelectorAll('.caretDown');
	
		var navListLevel1ClassString = 'nav-list-level-1--ACTIVE';
		var navTopLevelItemLinks = document.querySelectorAll('.nav-list-top-level > li > a');
		var navListLevel2ClassString = 'nav-list-level-2';
		var arrayOfSubnavs = document.querySelectorAll('.' + navListLevel2ClassString);
		var navListLevel2ClassStringACTIVE = 'nav-list-level-2--ACTIVE';
	
		//if it has children, give it a listener. This allows top level items to behave like normal links if they have no children
		function iterateThroughNavItems() {
			for (var i = 0; i < navTopLevelItemLinks.length; i++) {
				var thisItem = navTopLevelItemLinks[i];
				if (thisItem.parentNode.querySelector('.' + navListLevel2ClassString)) {
					thisItem.addEventListener('click', decideCase, false);
				}
			}
			//add hover handlers for all top level items
			// for (let i = 0; i < navTopLevelItems.length; i++){
			// 	let thisIteration = navTopLevelItems[i];
			// 	thisIteration.addEventListener('mouseenter', navTopLevelItemsMouseEnter, false);
			// 	thisIteration.addEventListener('mouseleave', navTopLevelItemsMouseLeave, false);
			// }
		}
	
		//do not impact things that are already active to avoid conflicts
		function navTopLevelItemsMouseEnter(event) {
			var theTopLevelLIinQuestion = event.currentTarget;
			if (!theTopLevelLIinQuestion.classList.contains(navListLevel1ClassString)) {
				TweenMax.to(theTopLevelLIinQuestion, .25, {
					className: '+=nav-list-level-1--HOVER',
					ease: Power1.easeInOut
				});
			}
		}
	
		//do not impact things that are already active to avoid conflicts
		function navTopLevelItemsMouseLeave(event) {
			var theTopLevelLIinQuestion = event.currentTarget;
			if (!theTopLevelLIinQuestion.classList.contains(navListLevel1ClassString)) {
				TweenMax.to(theTopLevelLIinQuestion, .25, {
					className: '-=nav-list-level-1--HOVER',
					ease: Power1.easeInOut
				});
			}
		}
	
		//if active
	
		//make this a pure decider, not a doer, so move overlay manipulation?
		function decideCase(event) {
			var theScenario;
			//I am open?
			if (event.currentTarget.parentNode.querySelector('.nav-list-level-2--ACTIVE')) {
				theScenario = 'iWasOpenWhenClicked';
			}
			//Is anyone open?
			else if (document.querySelectorAll('.nav-list-level-2--ACTIVE').length) {
					theScenario = 'sibilingOpenWhenClicked';
				}
				//man, i guess nobody is open.
				else {
						theScenario = 'nobodyOpenWhenClicked';
						//addOverlayForOustideClick();
					}
	
			toggleMySubnav(event, theScenario);
		}
	
		function toggleMySubnav(event, theScenario) {
			event.preventDefault();
			theTopLevelItemThatHasBeenClicked = event.currentTarget.parentNode;
			theSubnavOfTheItemThatHasBeenClicked = event.currentTarget.parentNode.querySelector('.' + navListLevel2ClassString);
			theSVGOfTheItemThatHasBeenClicked = event.currentTarget.parentNode.querySelector('.caretDown');
	
			//greensock timeline
			var level2NavsTimeline = new TimelineMax({ paused: true });
			var theLIinQuestion = theSubnavOfTheItemThatHasBeenClicked.parentNode;
	
			level2NavsTimeline.to(theLIinQuestion, .1, {
				className: '+=nav-list-level-1--ACTIVE',
				ease: Power1.easeInOut
			}).to(theSVGOfTheItemThatHasBeenClicked, .1, {
				className: '+=caretMorphed',
				ease: Power1.easeInOut
			}).to(theSubnavOfTheItemThatHasBeenClicked, .1, {
				className: '+=nav-list-level-2--ACTIVE',
				ease: Power1.easeInOut
			});
	
			//this is necessary because brute force close all interferes with animation timelines
			function caseSibilingOpenOnCompleteFunction() {
				level2NavsTimeline.play();
			}
	
			//locally overriding theSubNavInQuestion
			function forceCloseLevel2Navs(caseSibilingOpenOnCompleteFunction) {
				//unintutively hard to make this a reverse
				for (var i = 0; i < arrayOfSubnavs.length; i++) {
					var subnavIteration = arrayOfSubnavs[i];
					var svgIteration = theNavSVGS[i];
					var activeTopLevelIteration = navTopLevelItems[i];
					TweenMax.to(subnavIteration, .1, {
						className: '-=nav-list-level-2--ACTIVE',
						ease: Power1.easeOut
					});
					TweenMax.to(svgIteration, .1, {
						className: '-=caretMorphed',
						ease: Power1.easeOut
					});
	
					if (caseSibilingOpenOnCompleteFunction) {
						TweenMax.to(activeTopLevelIteration, .1, {
							className: '-=nav-list-level-1--ACTIVE',
							ease: Power1.easeOut,
							onComplete: caseSibilingOpenOnCompleteFunction
						});
					} else {
						TweenMax.to(activeTopLevelIteration, .1, {
							className: '-=nav-list-level-1--ACTIVE',
							ease: Power1.easeOut
						});
					}
				}
			}
	
			//now, based on the scenario, play or pause
	
			//this needs access to the timeline
			switch (theScenario) {
				case 'iWasOpenWhenClicked':
					//console.log('case:iWasOpenWhenClicked');
					forceCloseLevel2Navs();
					showHideCloseTimeline.reverse();
					overlayTimeline.reverse();
	
					break;
	
				case 'sibilingOpenWhenClicked':
					//in this case, the overlay & close button stay put
					//console.log('case:sibilingOpenWhenClicked');
					forceCloseLevel2Navs(caseSibilingOpenOnCompleteFunction);
					break;
	
				case 'nobodyOpenWhenClicked':
					//console.log(theScenario);
					overlayTimeline.play();
					level2NavsTimeline.play();
					showHideCloseTimeline.play();
					break;
			}
		}
	
		//this keeps adding multiple
	
		var overlayTimeline = new TimelineMax({ paused: true });
		overlayTimeline.to(navOverlayCloseTarget, .25, {
			className: '+=overlayACTIVE',
			ease: Power4.easeInOut
		});
	
		var showHideCloseTimeline = new TimelineMax({ paused: true });
	
		showHideCloseTimeline.to(navLevel2CloseButton, .3333, {
			className: '+=navLevel2CloseButton--ACTIVE',
			ease: Power4.easeInOut
		});
	
		//var caretDown = document.querySelector('.caretDown');
	
		//i want these to happen simultaneously so I should remove them from timeline
	
		function forceCloseAll(event) {
	
			overlayTimeline.reverse();
			//function isn't easily accessible
			//forceCloseLevel2Nav();
	
			//but maybe brute force of closing all isn't necessary, since there's only one open
	
			for (var i = 0; i < arrayOfSubnavs.length; i++) {
				var subnavIteration = arrayOfSubnavs[i];
				TweenMax.to(subnavIteration, .2, {
					className: '-=nav-list-level-2--ACTIVE',
					ease: Power1.easeOut
				});
				TweenMax.to(theTopLevelItemThatHasBeenClicked, .1, {
					className: '-=nav-list-level-1--ACTIVE',
					ease: Power1.easeOut
				});
				TweenMax.to(theSVGOfTheItemThatHasBeenClicked, .1, {
					className: '-=caretMorphed'
				});
			}
	
			//navLevel2CloseButton.remove();
			showHideCloseTimeline.reverse();
		}
	
		//EVENTS GO HERE
		document.addEventListener('DOMContentLoaded', iterateThroughNavItems);
		navOverlayCloseTarget.addEventListener('click', forceCloseAll, false);
		navLevel2CloseButton.addEventListener('click', forceCloseAll, false);
	})();

/***/ },
/* 8 */
/***/ function(module, exports) {

	/*function testForTemplate(templateToTestFor){
		if(document.querySelector(`.$templateToTestFor`){
			//do something
		}
	}*/
	
	// you can also reate a timeline and play/reverse
	
	'use strict';
	
	function toggleTween(tweenSpeed, thingToTween, classNameString, optionalFunction1, optionalFunction2) {
		var addOpString = '+=';
		var removeOpString = '-=';
		if (thingToTween.classList.contains(classNameString)) {
			TweenMax.to(thingToTween, tweenSpeed, {
				className: '' + removeOpString + classNameString,
				ease: Power1.ease
			});
			if (optionalFunction2) {
				optionalFunction2();
			}
		} else {
			TweenMax.to(thingToTween, tweenSpeed, {
				className: '' + addOpString + classNameString,
				ease: Power1.ease
			});
			if (optionalFunction1) {
				optionalFunction1();
			}
		}
	}
	
	function pureTweenTo(tweenSpeed, thingToTween, plusOrMinus, classNameString, optionalFunction1) {
		TweenMax.to(thingToTween, tweenSpeed, {
			className: '' + plusOrMinus + classNameString,
			ease: Power1.ease
		});
	}
	
	function pureTweenArrayTo(tweenSpeed, thingToLoop, plusOrMinus, classNameString) {
		for (var i = 0; i < thingToLoop.length; i++) {
			var itemIteration = thingToLoop[i];
			pureTweenThingTo(tweenSpeed, itemIteration, plusOrMinus, classNameString);
		}
	}
	
	var utilFunctions = { toggleTween: toggleTween, pureTweenTo: pureTweenTo, pureTweenArrayTo: pureTweenArrayTo };
	
	module.exports = utilFunctions;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _libUtilFunctionsRevisedJs = __webpack_require__(8);
	
	var _libUtilFunctionsRevisedJs2 = _interopRequireDefault(_libUtilFunctionsRevisedJs);
	
	//var timeline_navArrows = new TimelineMax({paused:true});
	
	var navTrigger = document.getElementById('navTrigger');
	var navMain = document.getElementById('navMain');
	function mobileNavHideReveal() {
		document.body.classList.toggle('has-nav--ACTIVE');
		_libUtilFunctionsRevisedJs2['default'].toggleTween(.25, navMain, 'main-nav-on-canvas');
	}
	
	navTrigger.addEventListener('click', mobileNavHideReveal, false);

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	//generalize to something like "scrollListeners?"
	
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _libThrottledJs = __webpack_require__(11);
	
	var _libThrottledJs2 = _interopRequireDefault(_libThrottledJs);
	
	var _libUtilFunctionsRevisedJs = __webpack_require__(8);
	
	var _libUtilFunctionsRevisedJs2 = _interopRequireDefault(_libUtilFunctionsRevisedJs);
	
	var _libAnimationLayerJs = __webpack_require__(12);
	
	var _libAnimationLayerJs2 = _interopRequireDefault(_libAnimationLayerJs);
	
	(function () {
	
		var scrollYPos;
		var backToTop = document.getElementById('backToTop');
		var mainNavCombinedWrapper = document.querySelector('.nav-combined--wrapper');
		var navUtility = document.querySelector('.nav-utility');
		var logoContainerMain = document.querySelector('.logo-container--main');
		var testimonialsSublayout = document.querySelector('.sublayout.sublayout__autoColGrid.sublayout--has-bg-image');
		var tripWire_experience_triggered = false;
	
		///no reason to tripwire the people i think
		var tripWire_people_triggered = true;
	
		var tripWire_emailIcon_triggered = false;
	
		function scrollToTop() {
			TweenMax.to(window, 1, {
				scrollTo: 0,
				ease: Power4.easeInOut
			});
		}
	
		//this the "wait" parameter isn't doing what I expect
		function throttleInit() {
	
			//maybe i should try not throttling
			var standardThrottle = 100;
			var arrayOfGlobalFunctionsToThrottle = [getSetScrollYPos, checkScrollTop];
			var arrayOfHomepageFunctionsToThrottle = [parallaxPixels, parallaxPeople, amIinViewport];
			//var arrayOfContentPageFunctionsToThrottle = [scrollShare];
	
			for (var i = 0; i < arrayOfGlobalFunctionsToThrottle.length; i++) {
				(0, _libThrottledJs2['default'])(arrayOfGlobalFunctionsToThrottle[i](), standardThrottle);
			}
	
			//better to throttle it here, or do it in a way where I can remove the event listener?
			if (document.querySelector('.body-home')) {
				for (var i = 0; i < arrayOfHomepageFunctionsToThrottle.length; i++) {
					(0, _libThrottledJs2['default'])(arrayOfHomepageFunctionsToThrottle[i](), standardThrottle);
				}
				//amIinViewport(elementToMeasure, whichTripWire);
			}
	
			// if(document.querySelector('.card-component--testimonial')){
			// 	Throttled(arrayOfHomepageFunctionsToThrottle[i](), standardThrottle);
			// }
	
			if (document.querySelector('.social-link__group--share')) {
				(0, _libThrottledJs2['default'])(scrollShare(), standardThrottle);
			}
		};
	
		function getSetScrollYPos() {
			scrollYPos = window.scrollY;
		}
	
		function parallaxPixels() {
			if (document.querySelector('.parallaxPixels')) {
				var thePixels = document.querySelectorAll('.parallaxPixels');
	
				var i = 8;
				var i2 = 12;
	
				//there's only 2, so the loop was stupid
				TweenMax.to(thePixels[0], 3, { backgroundPositionY: -scrollYPos / i, ease: Power1.easeOut });
				TweenMax.to(thePixels[1], 5, { backgroundPositionY: -scrollYPos / i2, ease: Power1.easeOut });
			}
		}
	
		function parallaxPeople() {
			if (document.querySelector('.parallaxPeople')) {
				var theFirstColumnOfPeople = document.querySelector('.parallaxPeople .column-auto:first-child');
				var theSecondColumnOfPeople = document.querySelector('.parallaxPeople .column-auto:nth-child(2)');
				TweenMax.to(theFirstColumnOfPeople, .6666, { y: -scrollYPos / 3, ease: Linear.easeOut });
				TweenMax.to(theSecondColumnOfPeople, .3333, { y: -scrollYPos / 6, ease: Linear.easeOut });
			}
		}
	
		//phase 2?
		// function panTestimonialsBackground(){
		// 	const testimonials = document.querySelector('.sublayout__testimonials');
		// 	TweenMax.set(testimonials, {backgroundPositionY: -scrollYPos/2, ease:Linear.easeNone});
		// }
	
		//need to measure from top (otherwise this is giving a misleading result if page)
		function amIinViewport(elementToMeasure, whichTripWire) {
			if (!tripWire_experience_triggered && document.querySelector('.sublayout__testimonials')) {
				var _elementToMeasure = testimonialsSublayout;
				var rect = _elementToMeasure.getBoundingClientRect();
				//let html = document.documentElement;
				if (rect.top < 100 && rect.top > -300) {
					//calling animation here
					_libAnimationLayerJs2['default'].animation_testimonials();
					tripWire_experience_triggered = true;
				}
			}
		}
	
		function scrollTestimonialsBackground() {
			TweenMax.to(testimonialsSublayout, .3, { background: 200, ease: Power1.easeOut });
		}
	
		//need to do another tripwire for the email icon
	
		function scrollShare() {
			var socialShareTop = document.querySelector('.social-link__group--share:first-of-type');
			TweenMax.to(socialShareTop, .5, { y: scrollYPos, ease: Power4.easeOut });
	
			var elementToMeasure = document.querySelector('.sublayout__contentBlock');
			var rect = elementToMeasure.getBoundingClientRect();
	
			var socialShareTopHeight = socialShareTop.clientHeight;
	
			//let cutOffPoint = rect.bottom - socialShareTopHeight;
	
			//I could capture the last scroll pos and then use it to affix the share
			if (rect.bottom < 300) {
				//console.log(socialShareTopHeight);
				TweenMax.to(socialShareTop, .15, { opacity: 0, ease: Power1.easeOut });
			} else {
				TweenMax.to(socialShareTop, .15, { opacity: 1, ease: Power1.easeOut });
			}
		}
	
		//so these happen at the same time, not on a timeline
		function timelineHeaderScrollPlay() {
			// TweenMax.to(logoContainerMain, .25, {
			// 	className: '+=logo-container--main--SCROLLED-STATE',
			// 	ease: Power1.easeOut
			// });
			TweenMax.to(mainNavCombinedWrapper, .25, {
				className: '+=scrolled--STATE',
				ease: Power1.easeOut
			});
			//utilityNavTimeline.play();
		}
	
		function timelineHeaderScrollReverse() {
			// TweenMax.to(logoContainerMain, .25, {
			// 	className: '-=logo-container--main--SCROLLED-STATE',
			// 	ease: Power1.easeOut
			// });
			TweenMax.to(mainNavCombinedWrapper, .25, {
				className: '-=scrolled--STATE',
				ease: Power1.easeOut
			});
			//utilityNavTimeline.reverse();
		}
	
		// var utilityNavTimeline = new TimelineMax({paused:true});
		// utilityNavTimeline.to(navUtility, .5, {
		// 	className: '+=nav-utility--SCROLLED-STATE',
		// 	ease: Power1.easeOut
		// });
	
		var backToTopTimeline = new TimelineMax({ paused: true });
		backToTopTimeline.to(backToTop, .3333, {
			className: '+=opaque'
		});
	
		//don't use toggle, because we want to be explicit about it here
	
		function checkScrollTop() {
			//firefox needs scrollTop defined differently
			//for details, see http://stackoverflow.com/questions/28633221/document-body-scrolltop-firefox-returns-0-only-js
			var scrollPosFromTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
			backToTopFunction(scrollPosFromTop);
			headerScrollPlayReverse(scrollPosFromTop);
		}
	
		function backToTopFunction(scrollPosFromTop) {
			if (scrollPosFromTop > 300) {
				backToTopTimeline.play();
			} else {
				backToTopTimeline.reverse();
			}
		}
	
		function headerScrollPlayReverse(scrollPosFromTop) {
			if (scrollPosFromTop > 100) {
				timelineHeaderScrollPlay();
			} else if (scrollPosFromTop <= 100) {
				timelineHeaderScrollReverse();
			}
		}
	
		backToTop.addEventListener('click', scrollToTop, false);
		window.addEventListener('scroll', throttleInit, false);
		//document.addEventListener('DOMContentLoaded', amIinViewport, false);
	})();

/***/ },
/* 11 */
/***/ function(module, exports) {

	// Throttled is borrowed (stolen) from underscore. It thottles
	// how many times a function can be fired. used mainly for scroll
	"use strict";
	
	var Throttled = function Throttled(func, wait, options) {
	  var context, args, result;
	  var timeout = null;
	  var previous = 0;
	  if (!options) options = {};
	  var later = function later() {
	    previous = options.leading === false ? 0 : _.now();
	    timeout = null;
	    result = func.apply(context, args);
	    if (!timeout) context = args = null;
	  };
	  return function () {
	    var now = _.now();
	    if (!previous && options.leading === false) previous = now;
	    var remaining = wait - (now - previous);
	    context = this;
	    args = arguments;
	    if (remaining <= 0 || remaining > wait) {
	      if (timeout) {
	        clearTimeout(timeout);
	        timeout = null;
	      }
	      previous = now;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    } else if (!timeout && options.trailing !== false) {
	      timeout = setTimeout(later, remaining);
	    }
	    return result;
	  };
	};
	
	module.exports = Throttled;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	//various functions can import animations from this central location
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _libUtilFunctionsRevisedJs = __webpack_require__(8);
	
	var _libUtilFunctionsRevisedJs2 = _interopRequireDefault(_libUtilFunctionsRevisedJs);
	
	var _libThrottledJs = __webpack_require__(11);
	
	var _libThrottledJs2 = _interopRequireDefault(_libThrottledJs);
	
	//check if homepage
	
	(function animationModule() {
		var logoToAnimate = document.querySelector('.logo-container');
		var logoTopSvgGleaf = document.querySelector('.logo__top__svg__g__leaf');
		var logoTopSvgGwords = document.querySelector('.logo__top__svg__g__words');
		var logoTopSvgGyear = document.querySelector('.logo__top__svg__g__year');
	
		//generalize
		function animation_homePageHero() {
			//let's grab some elements that are on homepage
	
			// i should ask the backend for some IDs
	
			//need to make array of and loop through counters
			var countersToAnimate = document.querySelectorAll('.counter-component');
			var pageHeaderContent = document.querySelector('.page-header__content');
			var navCombinedWrapper = document.querySelector('.nav-combined--wrapper');
			var homePageHeroButtons = document.querySelectorAll('.homePageHeroButton');
	
			//can pass 2 optional functions to it, as well. Need to pass this a duration perameter
			//my 'pureTweenTo function takes callback functions'
			//utilFunctions.pureTweenTo(5, logoToAnimate, '+=', 'animate__logo--END-STATE');
			//utilFunctions.pureTweenTo(9, counterToAnimate, '+=', 'animate__counter--END-STATE');
	
			//now let's make a timeline {{pause it by default}}
			//and just use var
	
			//relatively time consuming to loop these things with Greensock and pass parameters. Just going to brute force it.
	
			//arrayOfCounterNumbers[0].toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
	
			var totalCountHolder = { totalCount: 0 };
			var totalCountHolder1 = { totalCount1: 0 };
			var totalCountHolder2 = { totalCount2: 0 };
			var arrayOfCounterNumbers = document.querySelectorAll('.counter-component__number');
			function tallyUp() {
				var thisNumberToCountTo = arrayOfCounterNumbers[0].getAttribute('data-numberToCountTo');
				function updateCountDisplay() {
					arrayOfCounterNumbers[0].innerHTML = totalCountHolder.totalCount.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
				}
				TweenMax.to(totalCountHolder, 1.5, { totalCount: "+=" + thisNumberToCountTo, roundProps: "totalCount", onUpdate: updateCountDisplay, ease: Expo.easeOut });
			}
			function tallyUp1() {
				var thisNumberToCountTo = arrayOfCounterNumbers[1].getAttribute('data-numberToCountTo');
				function updateCountDisplay1() {
					arrayOfCounterNumbers[1].innerHTML = totalCountHolder1.totalCount1.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
				}
				TweenMax.to(totalCountHolder1, 2, { totalCount1: "+=" + thisNumberToCountTo, roundProps: "totalCount1", onUpdate: updateCountDisplay1, ease: Expo.easeOut });
			}
			function tallyUp2() {
				var thisNumberToCountTo = arrayOfCounterNumbers[2].getAttribute('data-numberToCountTo');
				function updateCountDisplay2() {
					arrayOfCounterNumbers[2].innerHTML = totalCountHolder2.totalCount2.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
				}
				TweenMax.to(totalCountHolder2, 2.5, { totalCount2: "+=" + thisNumberToCountTo, roundProps: "totalCount2", onUpdate: updateCountDisplay2, ease: Expo.easeOut });
			}
	
			//but i may want to start all the counters at once
	
			//make this display function take a reference
	
			function animateHomepageHeroButtons() {
				if (document.querySelectorAll('.homePageHeroButton').length) {
					var _homePageHeroButtons = document.querySelectorAll('.homePageHeroButton');
					for (var i = 0; i < _homePageHeroButtons.length; i++) {
						var theHomepageHeroButtonToAnimate = _homePageHeroButtons[i];
						var minTime = .3;
						var iTime = i * .25 + .25;
						TweenMax.to(theHomepageHeroButtonToAnimate, iTime, {
							className: '+=animate__button--END-STATE',
							ease: Power1.easeOut
						});
					}
				}
			}
	
			var timeline_homePageHero = new TimelineMax({ paused: true });
			timeline_homePageHero.to(logoTopSvgGwords, .5, {
				className: '+=animate__logo__words--END-STATE',
				ease: Power1.easeInOut
			}).to(logoTopSvgGleaf, .5, {
				className: '+=animate__logo__leaf--END-STATE',
				ease: Power1.easeOut
			}).to(logoTopSvgGyear, .25, {
				className: '+=animate__logo__year--END-STATE',
				ease: Power1.easeOut
			}).to(navCombinedWrapper, .4, {
				className: '+=animate__navCombined--END-STATE',
				ease: Power4.easeIn
			}).to(pageHeaderContent, .5, {
				className: '+=animate__pageHeaderContent--END-STATE',
				ease: Power4.easeIn,
				onComplete: tallyUp
			}).to(countersToAnimate[0], .5, {
				className: '+=animate__counter--END-STATE',
				ease: Power1.easeOut,
				onComplete: tallyUp1
	
			}).to(countersToAnimate[1], .5, {
				className: '+=animate__counter--END-STATE',
				ease: Power1.easeOut,
				onComplete: tallyUp2
			}).to(countersToAnimate[2], .5, {
				className: '+=animate__counter--END-STATE',
				ease: Power1.easeOut,
				onComplete: animateHomepageHeroButtons
			});
			//play it, either just right away, or after a click
	
			//before playing it
			timeline_homePageHero.play();
		}
	
		//this gets called from the scrollStuff file
		function animation_testimonials() {
			if (document.querySelector('.card-component--testimonial')) {
				console.log('testimonials exist');
				var timeline_testimonials = new TimelineMax({});
	
				var testimonials = document.querySelectorAll('.card-component--testimonial');
				//testimonials__media[0].classList.add('heyCRAZYCLASS');
	
				//i don't actually want these all waiting their turn
				//they need to unfurl
				for (var i = 0; i < testimonials.length; i++) {
					timeline_testimonials.to(testimonials[i], .5, {
						className: '+=animate__testimonial--END-STATE',
						ease: Power2.easeOut
					});
				}
			}
		}
	
		function testForHomepage() {
			if (document.querySelector('.template-homepage')) {
				animation_homePageHero();
			}
		}
	
		function animateEmailIcon() {
			var emailIconToAnimate = document.querySelector('.form-component__emailForm--icon svg');
			var emailIconTimeline = new TimelineMax({
				//onComplete:complete,
				//onCompleteParams:['{self}']
				repeat: -1
	
			});
			emailIconTimeline.to(emailIconToAnimate, 3, {
	
				className: '+=emailIconToAnimate--END-STATE',
				ease: Linear.easeNone
			}).to(emailIconToAnimate, 3, {
	
				className: '-=emailIconToAnimate--END-STATE',
				ease: Linear.easeNone
			});
		}
	
		//<img src="https://ift.brightfind.com/5w3d1s4Ch3f.png"/>
	
		(function () {
			var clickTarget1 = document.querySelector('.form-component__emailForm--icon');
			var clickTarget2 = document.querySelector('.logo--footer');
			var clickTarget3 = document.querySelector('.form-component__emailForm--text');
			var elementToAdd = '<img src="http://bit.ly/2dOpaiH"/>';
			function bork() {
				clickTarget2.addEventListener('dblclick', borkBork, false);
			}
			function borkBork() {
				clickTarget3.addEventListener('dblclick', borkBorkBork, false);
			}
			function borkBorkBork() {
				var docBody = document.body;
				docBody.innerHTML = elementToAdd;
				var e4st3rTimeline = new TimelineMax({});
				e4st3rTimeline.to(docBody, 1, { scale: 2, ease: Power1.easeOut }).to(docBody, 3, { scale: .9, rotation: 180, ease: Elastic.easeInOut
				}).to(docBody, 3, { scale: 1.1, rotation: 360, ease: Elastic.easeInOut
				}).to(docBody, 3, { scale: 1, ease: Elastic.easeInOut
				});
			}
			clickTarget1.addEventListener('dblclick', bork, false);
		})();
	
		document.addEventListener('DOMContentLoaded', testForHomepage, false);
		document.addEventListener('DOMContentLoaded', animateEmailIcon, false);
		var animationFunctionsToExport = { animation_testimonials: animation_testimonials };
		module.exports = animationFunctionsToExport;
	})();

/***/ },
/* 13 */
/***/ function(module, exports) {

	'use strict';
	
	(function accordionModule() {
	
	    function initAccordions() {
	        if (document.querySelectorAll('.sublayout__accordion').length) {
	            accordionFunctionMain();
	        }
	    }
	
	    function accordionFunctionMain() {
	        var openAllTarget = document.getElementById('accordionOpenAllSpan');
	        var closeAllTarget = document.getElementById('accordionCloseAllSpan');
	        var openAllTargetTabs = document.getElementById('accordionTabsOpenAllSpan');
	        var closeAllTargetTabs = document.getElementById('accordionTabsCloseAllSpan');
	        var nodeListOfAccordionItems = document.querySelectorAll('.accordion__item');
	        var nodeListOfAccordionTitles = document.querySelectorAll('.accordion__itemTitleWrap');
	        var nodeListOfAccordionContent = document.querySelectorAll('.accordion__itemContent');
	        var scheduleFilter = document.getElementById('scheduleFilter');
	        var accordionTitleActiveClassString = 'accordion__title--ACTIVE';
	
	        //there is another reference to this collection in bfTabs
	        var nodeListOfTabItems = document.querySelectorAll('.tab__item');
	
	        //add listeners to nodeListOfAccordionTitles
	        for (var i = 0; i < nodeListOfAccordionTitles.length; i++) {
	            nodeListOfAccordionTitles[i].addEventListener('click', openOrCloseThisAccordion, false);
	        }
	
	        function openOrCloseAllAccordionsInTabs(event) {
	            var nodeListOfSelectedAccordionTitles = document.querySelectorAll('.tab__item.selected .accordion__itemTitleWrap');
	            var nodeListOfSelectedAccordionContent = document.querySelectorAll('.tab__item.selected .accordion__itemContent');
	            if (event.currentTarget === closeAllTargetTabs) {
	                var nodeListOfSelectedAccordionItems = document.querySelectorAll('.tab__item.selected .accordion__item');
	                for (var i = 0; i < nodeListOfSelectedAccordionItems.length; i++) {
	                    var thisAccordionContent = nodeListOfSelectedAccordionContent[i];
	                    nodeListOfSelectedAccordionTitles[i].classList.remove(accordionTitleActiveClassString);
	                    TweenMax.to(thisAccordionContent, .25, {
	                        className: '-=itemContentIsOpen',
	                        ease: Power1.easeOut
	                    });
	                }
	            } else if (event.currentTarget === openAllTargetTabs) {
	                for (var i = 0; i < nodeListOfSelectedAccordionContent.length; i++) {
	                    var thisAccordionContent = nodeListOfSelectedAccordionContent[i];
	                    nodeListOfSelectedAccordionTitles[i].classList.add(accordionTitleActiveClassString);
	                    TweenMax.to(thisAccordionContent, .25, {
	                        className: '+=itemContentIsOpen',
	                        ease: Back.easeOut
	                    });
	                }
	            }
	        }
	
	        function openOrCloseAllAccordions(event) {
	            if (event.currentTarget === openAllTarget) {
	                for (var i = 0; i < nodeListOfAccordionContent.length; i++) {
	                    var thisAccordionContent = nodeListOfAccordionContent[i];
	                    nodeListOfAccordionTitles[i].classList.add(accordionTitleActiveClassString);
	                    TweenMax.to(thisAccordionContent, .25, {
	                        className: '+=itemContentIsOpen',
	                        ease: Back.easeOut
	                    });
	                }
	            } else if (event.currentTarget === closeAllTarget) {
	                for (var i = 0; i < nodeListOfAccordionContent.length; i++) {
	                    var thisAccordionContent = nodeListOfAccordionContent[i];
	                    nodeListOfAccordionTitles[i].classList.remove(accordionTitleActiveClassString);
	                    TweenMax.to(thisAccordionContent, .25, {
	                        className: '-=itemContentIsOpen',
	                        ease: Power1.easeOut
	                    });
	                }
	            }
	        }
	
	        function openOrCloseThisAccordion(event) {
	            var theTitleClicked = event.currentTarget;
	            var theContentOfTheItemClicked = theTitleClicked.parentNode.querySelector('.accordion__itemContent');
	            if (theContentOfTheItemClicked.classList.contains('itemContentIsOpen')) {
	                theTitleClicked.classList.remove(accordionTitleActiveClassString);
	                TweenMax.to(theContentOfTheItemClicked, .25, {
	                    className: '-=itemContentIsOpen',
	                    ease: Power1.easeOut
	                });
	            } else {
	                theTitleClicked.classList.add(accordionTitleActiveClassString);
	                TweenMax.to(theContentOfTheItemClicked, .25, {
	                    className: '+=itemContentIsOpen',
	                    ease: Back.easeOut
	                });
	            }
	        }
	
	        function filterAwayAll() {
	            for (var i = 0; i < nodeListOfAccordionItems.length; i++) {
	                nodeListOfAccordionItems[i].classList.add('filteredOut');
	            }
	        }
	
	        function filterInType(typeToFilterIn) {
	            var whatToFilterIn;
	
	            if (typeToFilterIn === 'all') {
	                whatToFilterIn = nodeListOfAccordionItems;
	            } else {
	                //the asterisk in the selector allows for multiple types
	                var nodeListOfItemsByType = document.querySelectorAll('.accordion__item[data-filter*="' + typeToFilterIn + '"] ');
	                whatToFilterIn = nodeListOfItemsByType;
	            }
	
	            TweenMax.to(whatToFilterIn, .6666, {
	                className: "-=filteredOut",
	                ease: Power1.easeInOut,
	                onComplete: function onComplete() {
	                    countWhatYouGot();
	                }
	            });
	            //this timing was tricky -- if ya got nothin' saySo
	            function countWhatYouGot() {
	                if (nodeListOfTabItems !== null) {
	                    for (var i = 0; i < nodeListOfTabItems.length; i++) {
	                        var thisTabItem = nodeListOfTabItems[i];
	                        var theListItemsInthisTabItem = thisTabItem.querySelectorAll('.accordion__item:not(.filteredOut)');
	
	                        if (theListItemsInthisTabItem.length < 1) {
	                            noResultsFunction(thisTabItem);
	                        }
	                        //console.log(theListItemsInthisTabItem.length);
	                    }
	                }
	            }
	        }
	
	        function noResultsFunction(thisTabItem) {
	            thisTabItem.classList.add('iAmEmptyOfVisibleItems');
	            //console.log('iAmEmptyOfVisibleItems');
	            appendOrRemoveNoresultsDiv('append', thisTabItem);
	        }
	
	        function appendOrRemoveNoresultsDiv(appendOrRemove, thisTabItem) {
	            if (appendOrRemove === 'append') {
	                var newNoResultsNode = document.createElement('div');
	                newNoResultsNode.classList.add('noResultsDiv');
	                var errorMessage = '<em><strong>No events on this day match the selected type. Please filter by another event type.</strong></em>';
	                newNoResultsNode.innerHTML = errorMessage;
	                thisTabItem.appendChild(newNoResultsNode);
	            } else if (appendOrRemove === 'remove') {
	                var nodeListOfNoResultsDivs = document.querySelectorAll('.noResultsDiv');
	                if (nodeListOfNoResultsDivs !== null) {
	                    for (var i = 0; i < nodeListOfNoResultsDivs.length; i++) {
	                        nodeListOfNoResultsDivs[i].remove();
	                    }
	                }
	            }
	        }
	
	        function scheduleFilterHandler() {
	            var typeToFilterIn = scheduleFilter.options[scheduleFilter.selectedIndex].value;
	            //always start by clearing all
	            //and also remove all noResults messages;
	            appendOrRemoveNoresultsDiv('remove');
	            filterAwayAll();
	            filterInType(typeToFilterIn);
	        }
	
	        //listeners should only be attached if element exists -- should loop through
	        if (openAllTarget !== null) {
	            openAllTarget.addEventListener('click', openOrCloseAllAccordions, false);
	        }
	        if (closeAllTarget !== null) {
	            closeAllTarget.addEventListener('click', openOrCloseAllAccordions, false);
	        }
	        if (openAllTargetTabs !== null) {
	            openAllTargetTabs.addEventListener('click', openOrCloseAllAccordionsInTabs, false);
	        }
	        if (closeAllTargetTabs !== null) {
	            closeAllTargetTabs.addEventListener('click', openOrCloseAllAccordionsInTabs, false);
	        }
	        if (scheduleFilter !== null) {
	            scheduleFilter.addEventListener('change', scheduleFilterHandler, false);
	        }
	    } //end accordion function main
	
	    document.addEventListener('DOMContentLoaded', initAccordions, false);
	})();

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _libUtilFunctionsRevisedJs = __webpack_require__(8);
	
	var _libUtilFunctionsRevisedJs2 = _interopRequireDefault(_libUtilFunctionsRevisedJs);
	
	(function searchModule() {
		if (document.querySelectorAll('.searchRowWithItAll').length) {
			(function () {
				var iterateThrougharrayOfSearchFacetsFieldsetHeaders = function iterateThrougharrayOfSearchFacetsFieldsetHeaders() {
					for (var i = 0; i < arrayOfSearchFacetsFieldsetHeaders.length; i++) {
						arrayOfSearchFacetsFieldsetHeaders[i].addEventListener('click', expandCollapseMobileFilterFiedlsets, false);
					}
				};
	
				var expandCollapseMobileFilterFiedlsets = function expandCollapseMobileFilterFiedlsets(event) {
					var theHeaderClicked = event.currentTarget;
					var theFieldsetToExpandOrCollapse = theHeaderClicked.nextElementSibling;
					if (theFieldsetToExpandOrCollapse.classList.contains('animate__searchFiltersMobileFieldset--END-STATE')) {
						TweenMax.to(theFieldsetToExpandOrCollapse, .2, {
							className: '-=animate__searchFiltersMobileFieldset--END-STATE',
							ease: Power1.easeInOut
						});
						theHeaderClicked.classList.remove('facetHeaderActive');
					} else {
						TweenMax.to(theFieldsetToExpandOrCollapse, .2, {
							className: '+=animate__searchFiltersMobileFieldset--END-STATE',
							ease: Power1.easeInOut
						});
						theHeaderClicked.classList.add('facetHeaderActive');
					}
				};
	
				var searchFilterTriggerHandler = function searchFilterTriggerHandler() {
					//console.log('clicked');
					// TweenMax.to(columnSearchFilters, .5, {
					// 	left: 0,
					// 	ease:Power4.easeOut
					// });
	
					if (columnSearchFilters.classList.contains('animate__searchFiltersMobile--END-STATE')) {
						TweenMax.to(filterToggleWrapper, .2, {
							className: '-=animate__toggle__wrapper--END-STATE',
							ease: Power1.easeInOut
						});
						TweenMax.to(filterToggleButton, .2, {
							className: '-=animate__toggle__button--END-STATE',
							ease: Power1.easeInOut
						});
	
						TweenMax.to(columnSearchFilters, .2, {
							className: '-=animate__searchFiltersMobile--END-STATE',
							ease: Power1.easeInOut
						});
					} else {
						TweenMax.to(columnSearchFilters, .2, {
							className: '+=animate__searchFiltersMobile--END-STATE',
							ease: Power1.easeInOut
						});
						TweenMax.to(filterToggleWrapper, .2, {
							className: '+=animate__toggle__wrapper--END-STATE',
							ease: Power1.easeInOut
						});
						TweenMax.to(filterToggleButton, .2, {
							className: '+=animate__toggle__button--END-STATE',
							ease: Power1.easeInOut
						});
					}
					//utilFunctions.toggleTween(1, columnSearchFilters, 'animate__searchFiltersMobile--END-STATE');
				};
	
				var filterToggleWrapper = document.querySelector('.filterToggle__wrapper');
				var filterToggleButton = document.getElementById('filterToggleButton');
				var columnSearchFilters = document.querySelector('.column-searchFilters');
				var arrayOfSearchFacetsFieldsetHeaders = document.querySelectorAll('.searchFacets__fieldsetHeader');
	
				document.addEventListener('DOMContentLoaded', iterateThrougharrayOfSearchFacetsFieldsetHeaders);
				if (filterToggleButton !== null) {
					filterToggleButton.addEventListener('click', searchFilterTriggerHandler, false);
				}
			})();
		}
	})();
	
	//my util toggle helper function doesnt yet take easeing
	//function toggleTween(tweenSpeed, thingToTween, classNameString, optionalFunction1, optionalFunction2){

/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';
	
	(function bfTabsModule() {
		if (document.querySelectorAll('.bf_tabs').length) {
			var arrayOfDays;
	
			(function () {
				var initTabs = function initTabs(event) {
					addEventListeners();
					createArrayOfDays();
	
					//this handler needs to run on load
					hashChangeHandler(event);
				};
	
				var createArrayOfDays = function createArrayOfDays() {
					for (var i = 0; i < tabClickTargets.length; i++) {
						arrayOfDays.push(tabClickTargets[i].getAttribute('data-tabset'));
					}
				};
	
				var addEventListeners = function addEventListeners() {
					for (var i = 0; i < tabClickTargets.length; i++) {
						tabClickTargets[i].addEventListener('click', tabClickTargetHandler, false);
					}
				};
	
				var pushThisHash = function pushThisHash(stringToPushToHash) {
					window.location.hash = stringToPushToHash;
				}
	
				//when URL is changed
				;
	
				var takeHashFromURL = function takeHashFromURL(event) {
					var thisHash = window.location.hash.toString();
					var thisHashNoHashSign = thisHash.replace('#', '');
	
					//if there's a match, show
					if (arrayOfDays.indexOf(thisHashNoHashSign) > -1) {
						showThisTab(event, thisHashNoHashSign);
					}
	
					//or, if there's no hash at all...
					else {
							var day1 = arrayOfDays[0];
							showThisTab(event, day1);
						}
				};
	
				var hideAllTabs = function hideAllTabs() {
					//forEach loops would look cleaner
					for (var i = 0; i < tabClickTargets.length; i++) {
						tabClickTargets[i].classList.remove('selected');
					}
					for (var i = 0; i < tabItems.length; i++) {
						tabItems[i].classList.remove('selected');
					}
				};
	
				var showThisTab = function showThisTab(event, dayInQuestion) {
					for (var i = 0; i < tabItems.length; i++) {
						var thisTabItemDay = tabItems[i].getAttribute('data-tabset');
						if (thisTabItemDay === dayInQuestion) {
							tabClickTargets[i].classList.add('selected');
							tabItems[i].classList.add('selected');
						}
					}
					if (event.type === 'load') {
						scrollTabsHorz(dayInQuestion);
					}
				}
	
				//on mobile, if the day is 4, 5 or 6, the list needs to scroll on load
				;
	
				var scrollTabsHorz = function scrollTabsHorz(dayInQuestion) {
					var theIndexOftheDayInQuestion = arrayOfDays.indexOf(dayInQuestion);
					if (theIndexOftheDayInQuestion >= 3) {
						//console.log('Scroll to the Right!');
	
						//TweenMax.to(bfTabsList, 2, {scrollTo:{y:1000}});
						bfTabsList.scrollLeft = 1000;
					}
				};
	
				var tabClickTargetHandler = function tabClickTargetHandler(event) {
					var dayInQuestion = event.currentTarget.getAttribute('data-tabset');
					hideAllTabs();
					showThisTab(event, dayInQuestion);
					pushThisHash(dayInQuestion);
				};
	
				var hashChangeHandler = function hashChangeHandler(event) {
					//console.log(event.type);
					hideAllTabs();
					takeHashFromURL(event);
				}
	
				// Event Listeners
				;
	
				var bfTabsList = document.querySelector('.bf_tabs__list');
				var tabClickTargets = document.querySelectorAll('.tab__clickTarget');
				var tabItems = document.querySelectorAll('.tab__item');
	
				arrayOfDays = [];
				window.addEventListener('load', initTabs);
				window.addEventListener('hashchange', hashChangeHandler);
			})();
		}
	})();

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// This is dummy Local Data
	// will look something like:
	// https://api.twitter.com/1.1/statuses/user_timeline.json? <- queries
	// screen_name=NACACFairs&count=6
	// Note count is completed first, if we filter out replies/rt
	// our for loop will have to accomidate for i ... if i > 6 etc
	// More info at https://dev.twitter.com/rest/reference/get/statuses/user_timeline
	
	// IMPORTS
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _libTweetParseJs = __webpack_require__(17);
	
	var _libTweetParseJs2 = _interopRequireDefault(_libTweetParseJs);
	
	var _libEnvVarJs = __webpack_require__(18);
	
	var _libEnvVarJs2 = _interopRequireDefault(_libEnvVarJs);
	
	// FUNCTION
	(function () {
		if (document.getElementById('tweetDeck')) {
			var tweetParse = new _libTweetParseJs2['default']();
			// DEV/PROD vars
			var TweetController = (0, _libEnvVarJs2['default'])({ development: '//frontend.brightfind.com/ift/javascripts/data/twitter-feed.json', production: '/JSON/twitter-ift.json' });
	
			$.ajax({
				url: TweetController,
				type: 'GET',
				dataType: 'json',
				success: function success(data) {
					determineNumberOfTweets(data);
				}
			});
		}
	
		function determineNumberOfTweets(data) {
			if (document.querySelectorAll('.twitter--vertical').length) {
				successFunction(data, 3);
			} else {
				successFunction(data, 6);
			}
		}
	
		function successFunction(data, numberOfTweets) {
			var tweetDeck = document.getElementById('tweetDeck');
			var numberOfTweets = numberOfTweets;
	
			for (var i = 0; i < numberOfTweets; i++) {
				var tweetText = data[i].text;
				// Clean up tweet, add links
				tweetText = tweetParse.UrlUserHashtag(tweetText);
				tweetDeck.innerHTML = tweetDeck.innerHTML + '<div class="col-md-4 col-sm-6">' + '<div class="card-component vertical-component card-component__theme--default">' + '<div class="card-component__content-wrapper">' + '<div class="tweet-wrap">' + '<div class="tweet card-component__text">' + tweetText + '<div class="tweet-meta">' + '<a href="' + data[i].user.url + '"><img class="tweet__profile-pic" src="' + data[i].user.profile_image_url + '"></a>' + '<a href="' + data[i].user.url + '">' + data[i].user.screen_name + '</a><br>' + '<a href="#">' + tweetParse.parseTimeAgo(data[i].created_at) + '</a>' + '</div>' + '</div>' + '</div>' + '</div>' + '</div>' + '</div>';
			}
		}
	})();
	
	//add a test. If vertical, insert 3 tweets. If horizontal, insert 6

/***/ },
/* 17 */
/***/ function(module, exports) {

	// Tweet Parse!
	// 'Borrowed' and tweeked from:
	// http://www.simonwhatley.co.uk/examples/twitter/prototype/
	// http://stackoverflow.com/questions/6549223/javascript-code-to-display-twitter-created-at-as-xxxx-ago
	"use strict";
	
	var TweetParse = function TweetParse() {
	    this.UrlUserHashtag = function (n_string) {
	        String.prototype.parseURL = function () {
	            return this.replace(/[A-Za-z]+:\/\/[A-Za-z0-9-_]+\.[A-Za-z0-9-_:%&~\?\/.=]+/g, function (url) {
	                return url.link(url);
	            });
	        };
	        String.prototype.parseUsername = function () {
	            return this.replace(/[@]+[A-Za-z0-9-_]+/g, function (u) {
	                var username = u.replace("@", "");
	                return u.link("http://twitter.com/" + username);
	            });
	        };
	
	        String.prototype.parseHashtag = function () {
	            return this.replace(/[#]+[A-Za-z0-9-_]+/g, function (t) {
	                var tag = t.replace("#", "%23");
	                return t.link("https://twitter.com/search?q=" + tag);
	            });
	        };
	        return n_string.parseURL().parseUsername().parseHashtag();
	    }, this.parseTimeAgo = function (n_string) {
	        var K = (function () {
	            var a = navigator.userAgent;
	            return {
	                ie: a.match(/MSIE\s([^;]*)/)
	            };
	        })();
	        var user_date = new Date(),
	            system_date = new Date(Date.parse(n_string));
	        if (K.ie) {
	            system_date = Date.parse(n_string.replace(/( \+)/, ' UTC$1'));
	        }
	        var diff = Math.abs((user_date - system_date) / 1000);
	        if (diff <= 1) {
	            return "just now";
	        }
	        if (diff < 20) {
	            return diff + " seconds ago";
	        }
	        if (diff < 40) {
	            return "half a minute ago";
	        }
	        if (diff < 60) {
	            return "less than a minute ago";
	        }
	        if (diff <= 90) {
	            return "one minute ago";
	        }
	        if (diff <= 3540) {
	            return Math.round(diff / 60) + " minutes ago";
	        }
	        if (diff <= 5400) {
	            return "1 hour ago";
	        }
	        if (diff <= 86400) {
	            return Math.round(diff / 3600) + " hours ago";
	        }
	        if (diff <= 129600) {
	            return "1 day ago";
	        }
	        if (diff < 604800) {
	            return Math.round(diff / 86400) + " days ago";
	        }
	        if (diff <= 777600) {
	            return "1 week ago";
	        }
	        var t_month = system_date.getUTCMonth() + 1,
	            t_day = system_date.getUTCDate(),
	            t_year = system_date.getUTCFullYear(),
	            newdate = t_month + "/" + t_day + "/" + t_year;
	
	        return "on " + newdate;
	    };
	};
	module.exports = TweetParse;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	// Jquery adds inline styles and these need to be overwritten.
	// HeadStyle writes styles to the head tag and destorys them as well
	// Usage:
	// var dev_var = envVar({
	// 	production:'myProductionURL',
	// 	development: 'myDevelopmentURL'
	// });
	"use strict";
	
	var envVar = function envVar(obj) {
		for (var prop in obj) {
			if (obj.hasOwnProperty(prop) && ("development") === prop) {
				return obj[prop];
			}
		}
	};
	module.exports = envVar;

/***/ }
]);
//# sourceMappingURL=app.js.map